import openmdao.api as om
import numpy as np
from .utils import LinearDensityFilter, PenalizeDensity, Mass, SmoothStep
from .FEM_comp import FEM
from collections.abc import Iterable

class SIMP(om.Group):
    """
    A SIMP implementation of topology optimization.

    Inputs
    ------
    density_dv : float
        Density design variable input, shape (num_x - 1) * (num_y - 1)
    
    Outputs
    -------
    mass : float
        Sum of the densities (after being filtered and potentially smooth-stepped), scalar
    max_temp : float
        Maximum nodal temperature computed with a KS aggregation, scalar
    density : float
        Densities post filtering (passing through a smooth step if use_smoothstep = True), (num_x - 1) * (num_y - 1)
    temp : float
        Nodal temperatures, shape num_x * num_y
    
    Options
    -------
    num_x : int
        Number of mesh coordinates in the x direction.
    num_y : int
        Number of mesh coordinates in the y direction.
    x_lim : 2-element iterable
        Lower and upper limits of the x coordinates.
    y_lim : 2-element iterable
        Lower and upper limits of the y coordinates.
    T_set : numpy array (num x-coord x num y-coord)
        Array with specified nodal temperatures. The temperature of any node where the corresponding
        entry in T is finite (not infinite or NaN) is set to the value of that entry.
    q : numpy array (num x-coord - 1 x num y-coord - 1)
        Heat generated by each element.
    conductivity : float
        Material thermal conductivity, by default 1000.
    plot : list
        List with the output folder and frequency at which to plot, for example ["~/Documents/plot", 10],
        by default will not plot. Make sure the directory is absolute, not relative!
    airport_data : dict
        If plot is set to something, pass in the dictionary returned by load_airport
        to plot airport buildings and the runways.
    r : float
        Filter radius. The dimensions correspond to the dimensions of
        the mesh (x and y limit options), by default 1e-2.
    p : float
        Penalty factor; exponent on densities passed in, by default 3.
    ks_rho : float
        KS aggregation parameter, by default 20.
    use_smoothstep : bool
        If true, will add a smooth step function after the densities have been filtered.
    smoothstep_kwargs : dict
        Dictionary of keyword arguments passed to the SmoothStep component (see its docstring for more info).
        The num_x and num_y options will be set automatically using the ones passed to SIMP.
    """

    def initialize(self):
        self.options.declare("num_x", types=int, desc="Number of mesh coordinates in the x direction")
        self.options.declare("num_y", types=int, desc="Number of mesh coordinates in the y direction")
        self.options.declare("x_lim", default=(0.0, 1.0), types=Iterable, desc="Lower and upper bounds on x range")
        self.options.declare("y_lim", default=(0.0, 1.0), types=Iterable, desc="Lower and upper bounds on y range")
        self.options.declare("T_set", types=np.ndarray, desc="Nodal temperatures to hold constant")
        self.options.declare("q", types=np.ndarray, desc="Heat generated by each element")
        self.options.declare("conductivity", default=1e3, types=float, desc="Material thermal conductivity")
        self.options.declare("plot", default=None, desc="List with the output folder and frequency at which to plot")
        self.options.declare("airport_data", default=None, desc="Airport data to make the plot cool")
        self.options.declare("r", default=1e-2, types=float, desc="Filter radius")
        self.options.declare("p", default=3.0, types=float, desc="Penalty factor")
        self.options.declare("ks_rho", default=20.0, types=float, desc="KS aggregation parameter")
        self.options.declare("use_smoothstep", default=False, types=bool, desc="Add a smooth step after the filtering")
        self.options.declare(
            "smoothstep_kwargs",
            default={},
            types=dict,
            desc="Keyword arguments for SmoothStep other than num_x and num_y, which are added automatically",
        )

    def setup(self):
        nx, ny = (self.options["num_x"], self.options["num_y"])
        xlim, ylim = (self.options["x_lim"], self.options["y_lim"])
        use_step = self.options["use_smoothstep"]

        # Filtered densities become the "physical" ones if the step isn't used, otherwise it's post step densities
        self.add_subsystem(
            "filter",
            LinearDensityFilter(num_x=nx, num_y=ny, x_lim=xlim, y_lim=ylim, r=self.options["r"]),
            promotes_inputs=[("density", "density_dv")],
            promotes_outputs=[("density_filtered", "density")] if not use_step else [],
        )

        if use_step:
            kwargs = self.options["smoothstep_kwargs"]
            kwargs["num_x"] = nx
            kwargs["num_y"] = ny
            self.add_subsystem("step", SmoothStep(**kwargs), promotes_outputs=[("out", "density")] if use_step else [])

        self.add_subsystem("calc_mass", Mass(num_x=nx, num_y=ny), promotes_outputs=["mass"])

        self.add_subsystem("penalize", PenalizeDensity(num_x=nx, num_y=ny, p=self.options["p"]))
        self.fem = self.add_subsystem(
            "fem",
            FEM(
                num_x=nx,
                num_y=ny,
                x_lim=xlim,
                y_lim=ylim,
                T_set=self.options["T_set"],
                q=self.options["q"],
                conductivity=self.options["conductivity"],
                plot=self.options["plot"],
                airport_data=self.options["airport_data"],
            ),
            promotes_outputs=["temp"]
        )

        self.add_subsystem(
            "calc_max_temp",
            om.KSComp(width=nx * ny, rho=self.options["ks_rho"]),
            promotes_outputs=[("KS", "max_temp")],
        )

        self.connect("density", ["penalize.density", "calc_mass.density"])
        self.connect("penalize.density_penalized", "fem.density")
        self.connect("temp", "calc_max_temp.g")

    def get_mesh(self):
        return self.fem.get_mesh()

    def get_fem_comp(self):
        return self.fem
