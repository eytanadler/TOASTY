import openmdao.api as om
import numpy as np
from .utils import LinearDensityFilter, PenalizeDensity, Mass, SmoothStep, MaskKeepOut
from .FEM_comp import FEM
from collections.abc import Iterable
import os
from copy import deepcopy

class SIMP(om.Group):
    """
    A SIMP implementation of topology optimization.

    Inputs
    ------
    density_dv : float
        Density design variable input, shape (num_x - 1) * (num_y - 1)
    
    Outputs
    -------
    mass : float
        Sum of the densities (after being filtered and potentially smooth-stepped), scalar
    max_temp : float
        Maximum nodal temperature computed with a KS aggregation, scalar. When multipoint cases
        are used (by setting T_set and q options to dictionaries), there becomes a temp and max_temp
        output for each multipoint case and the multipoint case names are appended to each temp and
        max_temp output name.
    density : float
        Densities post filtering (passing through a smooth step if use_smoothstep = True), (num_x - 1) * (num_y - 1)
    temp : float
        Nodal temperatures, shape num_x * num_y.  When multipoint cases are used (by setting T_set
        and q options to dictionaries), there becomes a temp and max_temp output for each multipoint
        case and the multipoint case names are appended to each temp and max_temp output name.
    
    Options
    -------
    num_x : int
        Number of mesh coordinates in the x direction.
    num_y : int
        Number of mesh coordinates in the y direction.
    x_lim : 2-element iterable
        Lower and upper limits of the x coordinates.
    y_lim : 2-element iterable
        Lower and upper limits of the y coordinates.
    T_set : numpy array (num x-coord x num y-coord) or dict
        Array with specified nodal temperatures. The temperature of any node where the corresponding
        entry in T is finite (not infinite or NaN) is set to the value of that entry. T_set can also
        be set to a dictionary where the keys are the multipoint case names and the values are the
        T_set arrays. In this case, q must also be a dictionary with the same keys. When multipoint
        cases are used, the multipoint case name is appended to the temp and max_temp output names.
    q : numpy array (num x-coord - 1 x num y-coord - 1) or dict
        Heat generated by each element. q can also be set to a dictionary where the keys are the
        multipoint case names and the values are the q arrays. In this case, T_set must also be a
        dictionary with the same keys. When multipoint cases are used, the multipoint case name is
        appended to the temp and max_temp output names.
    keep_out : numpy array (num x-coord - 1 x num y-coord - 1)
        One where the keep out zones are and zero where the optimizer can modify. This will limit the
        maximum temperature constraint to consider only the regions the optimizer can affect. If there
        are keep out zones, make sure to specify this!
    conductivity : float
        Material thermal conductivity, by default 1000.
    plot : list
        List with the output folder and frequency at which to plot, for example ["~/Documents/plot", 10],
        by default will not plot. Make sure the directory is absolute, not relative! In the multipoint
        case, subdirectories are made for each multipoint case.
    clim : list, tuple, or dict
        Iterable with the lower and upper bounds for the colorbar when plotting. In the multipoint case,
        this can be a dictionary where the keys are the case names and the values are the list/tuple
        with the colorbar limits.
    airport_data : dict
        If plot is set to something, pass in the dictionary returned by load_airport
        to plot airport buildings and the runways.
    r : float
        Filter radius. The dimensions correspond to the dimensions of
        the mesh (x and y limit options), by default 1e-2.
    p : float
        Penalty factor; exponent on densities passed in, by default 3.
    ks_rho : float
        KS aggregation parameter, by default 20.
    use_smoothstep : bool
        If true, will add a smooth step function after the densities have been filtered.
    smoothstep_kwargs : dict
        Dictionary of keyword arguments passed to the SmoothStep component (see its docstring for more info).
        The num_x and num_y options will be set automatically using the ones passed to SIMP.
    """

    def initialize(self):
        self.options.declare("num_x", types=int, desc="Number of mesh coordinates in the x direction")
        self.options.declare("num_y", types=int, desc="Number of mesh coordinates in the y direction")
        self.options.declare("x_lim", default=(0.0, 1.0), types=Iterable, desc="Lower and upper bounds on x range")
        self.options.declare("y_lim", default=(0.0, 1.0), types=Iterable, desc="Lower and upper bounds on y range")
        self.options.declare("T_set", types=(np.ndarray, dict), desc="Nodal temperatures to hold constant")
        self.options.declare("q", types=(np.ndarray, dict), desc="Heat generated by each element")
        self.options.declare("keep_out", types=(np.ndarray), default=None, desc="Keep out zones for the optimizer")
        self.options.declare("conductivity", default=1e3, types=float, desc="Material thermal conductivity")
        self.options.declare("plot", default=None, desc="List with the output folder and frequency at which to plot")
        self.options.declare("clim", types=(list, tuple, dict), default=None, desc="Limits for colorbar when plotting")
        self.options.declare("airport_data", default=None, desc="Airport data to make the plot cool")
        self.options.declare("r", default=1e-2, types=float, desc="Filter radius")
        self.options.declare("p", default=3.0, types=float, desc="Penalty factor")
        self.options.declare("ks_rho", default=20.0, types=float, desc="KS aggregation parameter")
        self.options.declare("use_smoothstep", default=False, types=bool, desc="Add a smooth step after the filtering")
        self.options.declare(
            "smoothstep_kwargs",
            default={},
            types=dict,
            desc="Keyword arguments for SmoothStep other than num_x and num_y, which are added automatically",
        )

    def setup(self):
        # Check if we're doing multipoint or not
        if type(self.options["T_set"]) != type(self.options["q"]):
            raise TypeError("T_set and q options must both be numpy arrays or dictionaries")
        if isinstance(self.options["q"], dict):
            if self.options["T_set"].keys() != self.options["q"].keys():
                raise ValueError("T_set and q option dictionaries must contain data for the same multipoint cases")
            self.multipoint = True
        else:
            self.multipoint = False

        nx, ny = (self.options["num_x"], self.options["num_y"])
        n_elem = (nx - 1) * (ny - 1)
        xlim, ylim = (self.options["x_lim"], self.options["y_lim"])
        use_step = self.options["use_smoothstep"]
        keep_out = np.zeros(n_elem) if self.options["keep_out"] is None else self.options["keep_out"].flatten()

        # Filtered densities become the "physical" ones if the step isn't used, otherwise it's post step densities
        self.add_subsystem(
            "filter",
            LinearDensityFilter(num_x=nx, num_y=ny, x_lim=xlim, y_lim=ylim, r=self.options["r"]),
            promotes_inputs=[("density", "density_dv")],
            promotes_outputs=[("density_filtered", "density")] if not use_step else [],
        )

        if use_step:
            kwargs = self.options["smoothstep_kwargs"]
            kwargs["num_x"] = nx
            kwargs["num_y"] = ny
            self.add_subsystem("step", SmoothStep(**kwargs), promotes_outputs=[("out", "density")] if use_step else [])

        self.add_subsystem("calc_mass", Mass(num_x=nx, num_y=ny), promotes_outputs=["mass"])
        self.add_subsystem("penalize", PenalizeDensity(num_x=nx, num_y=ny, p=self.options["p"]))
        self.connect("density", ["penalize.density", "calc_mass.density"])

        # Add a FEM and KS component for each multipoint case if multipoint is on
        if self.multipoint:
            self.fem = []
            for case_name in self.options["q"].keys():
                # Add subfolder to plot images if plotting is requested
                plot_option = deepcopy(self.options["plot"])
                if plot_option is not None:
                    plot_option[0] = os.path.join(plot_option[0], case_name)

                # Colorbar limits
                if isinstance(self.options["clim"], dict):
                    clim = self.options["clim"][case_name]
                else:
                    clim = self.options["clim"]

                self.fem.append(self.add_subsystem(
                    f"fem_{case_name}",
                    FEM(
                        num_x=nx,
                        num_y=ny,
                        x_lim=xlim,
                        y_lim=ylim,
                        T_set=self.options["T_set"][case_name],
                        q=self.options["q"][case_name],
                        conductivity=self.options["conductivity"],
                        plot=plot_option,
                        clim=clim,
                        airport_data=self.options["airport_data"],
                    ),
                    promotes_outputs=[("temp", f"temp_{case_name}")]
                ))

                self.add_subsystem(
                    f"mask_keep_out_{case_name}",
                    MaskKeepOut(num_x=nx, num_y=ny, keep_out=keep_out),
                    promotes_inputs=[("temp", f"temp_{case_name}")]
                )

                self.add_subsystem(
                    f"calc_max_temp_{case_name}",
                    om.KSComp(width=nx * ny, rho=self.options["ks_rho"]),
                    promotes_outputs=[("KS", f"max_temp_{case_name}")],
                )

                self.connect("penalize.density_penalized", f"fem_{case_name}.density")
                self.connect(f"mask_keep_out_{case_name}.masked_temp", f"calc_max_temp_{case_name}.g")
        else:

            # Colorbar limits
            if isinstance(self.options["clim"], dict):
                raise ValueError("\"clim\" option cannot be a dictionary if not doing a multipoint case")
            else:
                clim = self.options["clim"]

            self.fem = self.add_subsystem(
                "fem",
                FEM(
                    num_x=nx,
                    num_y=ny,
                    x_lim=xlim,
                    y_lim=ylim,
                    T_set=self.options["T_set"],
                    q=self.options["q"],
                    conductivity=self.options["conductivity"],
                    plot=self.options["plot"],
                    clim=clim,
                    airport_data=self.options["airport_data"],
                ),
                promotes_outputs=["temp"]
            )

            self.add_subsystem(
                "mask_keep_out",
                MaskKeepOut(num_x=nx, num_y=ny, keep_out=keep_out),
                promotes_inputs=["temp"]
            )

            self.add_subsystem(
                "calc_max_temp",
                om.KSComp(width=nx * ny, rho=self.options["ks_rho"]),
                promotes_outputs=[("KS", "max_temp")],
            )

            self.connect("penalize.density_penalized", "fem.density")
            self.connect("mask_keep_out.masked_temp", "calc_max_temp.g")

    def get_mesh(self):
        if self.multipoint:
            return self.fem[0].get_mesh()
        else:
            return self.fem.get_mesh()

    def get_fem_comp(self):
        """
        Returns the FEM component if single point and a list of the FEM components if multipoint
        """
        return self.fem
